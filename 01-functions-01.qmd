---
title: "useR to programmeR"
subtitle: "👋 & Functions 1"
author: "Emma Rand and Ian Lyttle"
format: 
  revealjs:
    theme: [simple, styles.scss]
    slide-number: true
    chalkboard: true
    code-link: true
    code-line-numbers: false
bibliography: references.bib
---

# 👋 Welcome

## Introductions

This is a two-day, hands-on workshop for those who have embraced the tidyverse and want to improve their R programming skills and, especially, reduce the amount of duplication in their code.

-   do you have experience equivalent to an introductory data science course using tidyverse?
-   are you comfortable with the [Whole game](https://r4ds.hadley.nz/whole-game.html) chapter of [R for Data Science (2nd Edition)](https://r4ds.hadley.nz/) by by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund.

\

### Material

-   <https://posit-conf-2023.github.io/programming-r/>

## The team

::: columns
::: {.column width="55%"}
Emma Rand

🐘[\@3mma\@mastodon.social](https://mastodon.social/@3mma)

Stephanie Hazlitt
:::

::: {.column width="45%"}
Ian Lyttle

🐘[\@ijlyttle\@vis.social](https://mastodon.social/@ijlyttle@vis.social)

Mouna Belaid
:::
:::

 

Standing on the shoulders of

::: {style="font-size: 80%;"}
-   [R for Data Science (2e)](https://r4ds.hadley.nz/) @wickham2023

-   [The tidyverse style guide](https://style.tidyverse.org/index.html) @wickham

-   [Programming with dplyr vignette](https://dplyr.tidyverse.org/articles/programming.html) @dplyr
:::

\

### WiFi TOFIX

-   Username: `conf22`
-   Password: `together!`

## Introductions

To each other!

## Code of Conduct TOFIX

[Full Code of Conduct](https://posit.co/code-of-conduct/). **Please Review**

-   💙 Treat everyone with respect
-   🧡 Everyone should feel welcome and safe

Reporting:

-   🗣️ any posit::conf staff member (t-shirt) or Info desk
-   📧 `conf@posit.com`
-   ☎️ 844-448-1212

## Housekeeping TOFIX

-   WiFi:
    -   Username: `conf22`
    -   Password: `together!`
-   Gender neutral bathrooms xxxxxxxxx.
-   Meditation room xxxxx. 8am - 5pm, Monday - Thursday.
-   Lactation room xxxxx. 8am - 5pm, Monday - Thursday.
-   Participants who do not wish to be photographed have red lanyards

## 🙏 to

-   the Steph and Mouna

-   colleagues, friends and learners at Schneider Electric, University of York and RForwards!

-   Posit team and especially Mine Çetinkaya-Rundel

. . .

-   Ian!

. . .

-   Experience 🍱 🥗 🌮 🍴 🕐

## Prerequisites TOFIX

You need a laptop with the following installed:

-   R version ≥4.2 and RStudio ≥2023.03
-   The following packages: {tidyverse}, {palmerpenguins}

🎬 Detailed instructions for installing these were covered in [Prerequisites](pre-reqs.html)

## Schedule {.smaller}

| Time          | Activity                                                                                      |
|:---------------------|:---------------------------------------------------------------------------------------|
| 09:00 - 10:30 | [Functions 1](01-functions-01.html) Introduction, vector and dataframe functions, embracing   |
| 10:30 - 11:00 | ☕ *Coffee break*                                                                             |
| 11:00 - 12:30 | [Functions 2](02-functions-02.html) Plot functions, style and side effects                    |
| 12:30 - 13:30 | 🍱 🥗 🌮 🍴   *Lunch break*                                                                   |
| 13:30 - 15:00 | [Iteration 1](03-iteration-01.html) Introduction and modifying multiple columns               |
| 15:00 - 15:30 | ☕ *Coffee break*                                                                             |
| 15:30 - 17:00 | [Iteration 2](04-iteration-02.html) Reading and writing multiple files                        |

## How we will work TOFIX

-   stickies

    -   🟪 I'm all good, I'm done

    -   🟧 I could do with some help

-   Discord

-   no stupid questions

-   🎬 Action!

## Learning Objectives

At the end of this section you will be able to:

::: {style="font-size: 80%;"}
-   explain the rationale for writing functions
-   write vector functions
    -   that take one or more vectors as input and output a vector
    -   that take one or more vectors as input and output a single value
-   specify defaults for function argument
-   write functions that take dataframes as input and output a dataframe
-   using embracing to allow data masking and tidy selection within functions
:::

# Set up

## Project


https://github.com/posit-conf-2023/programming-r-exercises



🎬 Create a Project:

```{r}
#| eval: false

usethis::use_course("posit-conf-2023/programming-r-exercises")
```

##

```
> usethis::use_course("posit-conf-2023/programming-r-exercises")
✔ Downloading from 'https://github.com/posit-conf-2023/programming-r-exercises/zipball/HEAD'
Downloaded: 0.26 MB  
✔ Download stored in 'C:/Users/er13/OneDrive - University of York/Desktop/Desktop/posit-conf-2023-programming-r-exercises-978baff.zip'
✔ Unpacking ZIP file into 'posit-conf-2023-programming-r-exercises-978baff/' (45 files extracted)
Shall we delete the ZIP file ('posit-conf-2023-programming-r-exercises-978baff.zip')?

1: Not now
2: Yeah
3: Nope
```
🎬 Choose the option that means yes!

##

```
✔ Deleting 'posit-conf-2023-programming-r-exercises-978baff.zip'
✔ Opening project in RStudio
```
. . .

RStudio will restart

## Create a `.R`

```{r}
#| eval: false

usethis::use_r("functions-01")
```



## Packages


🎬 Load packages:

```{r}
library(tidyverse)
library(palmerpenguins)
```
```
── Attaching core tidyverse packages ──────────────────────────────────────────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.2     ✔ readr     2.1.4
✔ forcats   1.0.0     ✔ stringr   1.5.0
✔ ggplot2   3.4.2     ✔ tibble    3.2.1
✔ lubridate 1.9.2     ✔ tidyr     1.3.0
✔ purrr     1.0.1     ── Conflicts ────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package to force all conflicts to become errors'
```

## Load `penguins`


🎬 Load `penguins` data set

```{r}
data(penguins)
glimpse(penguins)
```

# Why write functions?

## Rationale

-   impact from code: reach and clarity
-   efficiency: update code in one place, decrease error rate, improve ability to reuse

## Example

We have several measurements `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm` and `body_mass_g`

```{r}
#| echo: false
#| layout-ncol: 2
penguins |> ggplot(aes(x = bill_length_mm)) +
  geom_histogram(bins = 20) 
penguins |> ggplot(aes(x = bill_depth_mm)) +
  geom_histogram(bins = 20) 
penguins |> ggplot(aes(x = flipper_length_mm)) +
  geom_histogram(bins = 20) 
penguins |> ggplot(aes(x = body_mass_g)) +
  geom_histogram(bins = 20) 
```

These are on very different scales

## Example

A common solution is to apply a $z$ score transformation to each variable which normalises the values to have a mean of 0 and a standard deviation of 1

$$z = \frac{x - \bar{x}}{s.d.}$$

## Example

We can apply the same transformation to each variable:

```{r}
penguins <- penguins |>
  mutate(
    z_bill_length_mm = (bill_length_mm - mean(bill_length_mm, na.rm = TRUE)) / sd(bill_length_mm, na.rm = TRUE),
    z_bill_depth_mm = (bill_depth_mm - mean(bill_depth_mm, na.rm = TRUE)) / sd(bill_depth_mm, na.rm = TRUE),
    z_flipper_length_mm = (flipper_length_mm - mean(flipper_length_mm, na.rm = TRUE)) / sd(flipper_length_mm, na.rm = TRUE),
    z_body_mass_g = (body_mass_g - mean(body_mass_g, na.rm = TRUE)) / sd(body_mass_g, na.rm = TRUE)
  )
```

How to shorten and make more clear: `(bill_length_mm - mean(bill_length_mm, na.rm = TRUE)) / sd(bill_length_mm, na.rm = TRUE)`

## Coping and pasting

1.  Error prone
2.  Difficult to follow: more code than needed, difficult to determine what the transformation is

key point: you may think you have to write complex functions - you don't, start with the simple things.

# Types of function

## Types of function

We will cover two types of function

1.  vector functions: one of more vectors as input, one vector as output

    i.  output same length as input. "mutate" functions will work well in `mutate()` and `filter()`. Principles of writing functions

    ii. summary functions: input is vector, output is a single value

2.  data frame functions: df as input and df as output

# Vector functions

## Output same length as input

-   output same length as input
-   work well in `mutate()`
-   appropriate for the example

## General

To turn your code into a function you need:

-   a name
-   the arguments - which represent the bits that vary
-   the code body for the function

``` r
name <- function(arguments) {
  code body
}
```

## Function name

Use a verb - The tidyverse style guide @wickham but good advice regardless

Difficulty in naming? Should this be two or three functions?

. . .

What should we call the function we write to do a $z$ score transformation?

## Arguments

-   the input vector

-   additional arguments

Naming conventions

-   x for the vector input

``` r
name <- function(x) {
  body does things with x
}
```

## Example

$$z = \frac{x - \bar{x}}{s.d.}$$

``` r
penguins <- penguins |>
  mutate(
    z_bill_length_mm = (bill_length_mm - mean(bill_length_mm, na.rm = TRUE)) / sd(bill_length_mm, na.rm = TRUE),
    z_bill_depth_mm = (bill_depth_mm - mean(bill_depth_mm, na.rm = TRUE)) / sd(bill_depth_mm, na.rm = TRUE),
    z_flipper_length_mm = (flipper_length_mm - mean(flipper_length_mm, na.rm = TRUE)) / sd(flipper_length_mm, na.rm = TRUE),
    z_body_mass_g = (body_mass_g - mean(body_mass_g, na.rm = TRUE)) / sd(body_mass_g, na.rm = TRUE)
  )
```

## Example

Identify the arguments: the things that vary across calls

``` r
 
(bill_length_mm    - mean(bill_length_mm,    na.rm = TRUE)) / sd(bill_length_mm,    na.rm = TRUE)
(bill_depth_mm     - mean(bill_depth_mm,     na.rm = TRUE)) / sd(bill_depth_mm,     na.rm = TRUE)
(flipper_length_mm - mean(flipper_length_mm, na.rm = TRUE)) / sd(flipper_length_mm, na.rm = TRUE)
(body_mass_g       - mean(body_mass_g,       na.rm = TRUE)) / sd(body_mass_g,       na.rm = TRUE)
```

. . .

``` r
 
(🟧 - mean(🟧, na.rm = TRUE)) / sd(🟧, na.rm = TRUE)
(🟧 - mean(🟧, na.rm = TRUE)) / sd(🟧, na.rm = TRUE)
(🟧 - mean(🟧, na.rm = TRUE)) / sd(🟧, na.rm = TRUE)
(🟧 - mean(🟧, na.rm = TRUE)) / sd(🟧, na.rm = TRUE)
```

🟧 is x

## Example

Put into the template

```{r}
to_z <- function(x) {
  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
}
```

## Apply

Rewrite the call to`mutate()` as:

```{r}
penguins <- penguins |>
  mutate(
    z_bill_length_mm = to_z(bill_length_mm),
    z_bill_depth_mm = to_z(bill_depth_mm),
    z_flipper_length_mm = to_z(flipper_length_mm),
    z_body_mass_g = to_z(body_mass_g)
  )
```

. . .

Much shorter, much more clear.

## A modification

`mean()` has a `trim` argument: `mean(x, trim = 0, na.rm = FALSE, ...)`

*the fraction (0 to 0.5) of observations to be trimmed from each end of x before the mean is computed.*

Suppose we want to specify the **middle** proportion left rather than the proportion trimmed from each end\[\^1\]

![Trim is the proportion trimmed off each end; middle is what's left](images/vector-functions-trim.png){fig-alt="schematic of trim and middle demonstflipper_length_mming that trim - (1 - middle)/2"}

## Add an argument

```{r}
to_z <- function(x, middle) {
  trim = (1 - middle)/2
  (x - mean(x, na.rm = TRUE, trim = trim)) / sd(x, na.rm = TRUE)
}
```

Try it out

```{r}
to_z(penguins$bill_length_mm, middle = 0.2)
```

But what if we forget?

```{r}
#| error: true
to_z(penguins$bill_length_mm)
```

## Give a default

Give defaults whenever possible:

```{r}
to_z <- function(x, middle = 1) {
  trim = (1 - middle)/2
  (x - mean(x, na.rm = TRUE, trim = trim)) / sd(x, na.rm = TRUE)
}
```

Try it out

```{r}
to_z(penguins$bill_length_mm)
```

## Your turn

🎬 Write a function that performs the Box-Cox power transformation using the value of (non-zero) lambda ($\lambda$) supplied.

$$bc = \frac{x^{\lambda} - 1}{\lambda}$$

## A solution

```{r}

```

## Summary functions

-   input is vector
-   output is a single value
-   could be used in `summarise()`

## Example

Write a function to compute the standard error of a sample.

$$s.e. = \frac{s.d.}{\sqrt{n}}$$

## Example

```{r}
sd_error <- function(x){
  sd(x, na.rm = TRUE) / sqrt(sum(!is.na(x)))
}

```

Note: `sum(TRUE)` = 1 and `sum(FALSE)` = 0 `sum(!is.na(x))` is a bit sorter than `length(x[!is.na(x)])`

## 

```{r}
sd_error(penguins$bill_length_mm)
```

```{r}
penguins |> 
  summarise(se = sd_error(bill_length_mm))
```

## Your turn

🎬 Write a function to compute the sums of squares (sum of the squared deviations from the mean)

$$SS(x) = \sum{(x - \bar{x})^2}$$

or

$$SS(x) = s^2 * (n-1)$$

## $SS(x)$

```{r}
sum_sq <- function(x){
 sum((x[!is.na(x)] - mean(x[!is.na(x)]))^2)
}
```

```{r}
sum_sq(penguins$bill_length_mm)
```

# Dataframe functions

## Dataframe functions

Dataframe as input and Dataframe as output

. . .

We might summarise one of our columns like this:

```{r}
penguins |> 
  summarise(mean = mean(bill_length_mm),
            n = length(bill_length_mm),
            sd = sd(bill_length_mm),
            se = sd_error(bill_length_mm))
```

Output is a dataframe

## 

and want to summarise several in the same way

```{r}
penguins |> 
  summarise(mean = mean(bill_depth_mm),
            n = length(bill_depth_mm),
            sd = sd(bill_depth_mm),
            se = sd_error(bill_depth_mm))
```

Good candidate for a function to avoid repetitive code: `my_summary()`

## Define `my_summary()` function

```{r}
my_summary <- function(df, column){
  df |> 
  summarise(mean = mean(column),
            n = length(column),
            sd = sd(column),
            se = sd_error(column))
}
```

## Use function

```{r}
#| error: true
my_summary(penguins, bill_length_mm)
```

😕

## Tidy evaluation

`tidyverse` functions like `dplyr::summarise()` use tidy evaluation so you can refer to the names of variables inside dataframes. For example, you can use:

``` r
penguins |> summarise(mean = mean(bill_depth_mm))
summarise(penguins, mean = mean(bill_depth_mm))
```

rather than

``` r
summarise(penguins, mean = mean(penguins$bill_depth_mm))
```

This is known as data-masking: the dataframe environment masks the user environment by giving priority to the dataframe.

## 

Because of data-masking, `summarise()` in `my_summary()` is looking for a column literally called `column` in the dataframe that has been passed in. It is not looking in the variable `column` for the name of column you want to give it.

[Programming with dplyr](https://dplyr.tidyverse.org/articles/programming.html)

## Tidy evaluation

-   easy to code interactively
-   harder to write functions

TODO: decide whether to go in to data masking and tidy selection more

## Fix `my_summary()` function

The solution is to use embracing: {{ var }}

```{r}
my_summary <- function(df, column){
  df |> 
  summarise(mean = mean({{ column }}),
            n = length({{ column }}),
            sd = sd({{ column }}),
            se = sd_error({{ column }}),
            .groups = "drop")
}
```

. . .

-   look inside `column` variable
-   style with spaces
-   `.groups = "drop"` to avoid message and leave the data in an ungrouped state

## Use function

```{r}
my_summary(penguins, bill_length_mm)
```

🎉

## When to embrace?

When tidy evaluation is used

## Your turn

🎬 Write a function to

## Extras

-   Short cuts:

    -   put cursor on a function call and press F2 to find its definition
    -   Ctrl+. opens section/file search

-   Document: Roxygen? ChatGTP?

-   Tests interactive? Unit tests with ChatGTP?

## Summary
